#!/usr/bin/env python3import subprocessimport requestsimport timeimport signalimport jsonimport platformimport osfrom datetime import datetimeNAMESPACE = "gobgp-lab"TARGET_PORT = 8080LOCAL_BASE_PORT = 18080TIMESTAMP = datetime.now().strftime("%Y%m%d-%H%M%S")EXPERIMENT_DIR = os.path.join("experiments", TIMESTAMP)os.makedirs(EXPERIMENT_DIR, exist_ok=True)REPORT_FILE = os.path.join(EXPERIMENT_DIR, "report.json")SEQUENCE = [    {"pod": "augsburg", "method": "POST", "path": "/pcap/start"},    {"pod": "aachen", "method": "POST", "path": "/noise/start",     "json": {"PREFIX_BLOCK": 0, "NUMBER_OF_BLOCKS": 1, "rate": 1.0,              "lifetime": 60, "jitter": 0.5, "max_active": 60}},    {"wait": 120},  # buildup time    {"pod": "aachen", "method": "POST", "path": "/noise/stop"},    {"gate": "measure_peak_and_drain", "pod": "augsburg"},    {"pod": "augsburg", "method": "POST", "path": "/pcap/stop"},]GATES = {}def gate(name):    def wrapper(fn):        GATES[name] = fn        return fn    return wrapperdef get_pod_by_prefix(prefix: str) -> str:    cmd = ["kubectl", "get", "pods", "-n", NAMESPACE, "-o", "json"]    out = subprocess.check_output(cmd, text=True)    data = json.loads(out)    for item in data["items"]:        name = item["metadata"]["name"]        phase = item["status"]["phase"]        if phase == "Running" and name.startswith(prefix):            return name    raise RuntimeError(f"No running pod found with prefix '{prefix}'")def port_forward(pod: str, local_port: int):    cmd = [        "kubectl", "port-forward",        f"pod/{pod}", f"{local_port}:{TARGET_PORT}",        "-n", NAMESPACE,    ]    return subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)def stop_process(proc):    if platform.system() == "Windows":        proc.terminate()    else:        proc.send_signal(signal.SIGINT)    try:        proc.wait(timeout=3)    except subprocess.TimeoutExpired:        proc.kill()def request_json(base_url, method, path, **kwargs):    func = getattr(requests, method.lower())    r = func(base_url + path, **kwargs)    try:        return r.status_code, r.json()    except Exception:        return r.status_code, r.text@gate("measure_peak_and_drain")def measure_peak_and_drain(base_url, step, results, state):    peak = 0    peak_ts = None    start_ts = time.time()    while True:        status, rib = request_json(base_url, "GET", "/rib/summary")        now = time.time()        if status == 200 and isinstance(rib, dict):            num_paths = rib.get("num_paths", 0)            if num_paths > peak:                peak = num_paths                peak_ts = now            results.append({"ts": now, "rib": rib})            if num_paths == 0 and peak > 0:                break        time.sleep(5)    time_to_zero = now - start_ts    lag_to_peak = None    if peak_ts:        lag_to_peak = peak_ts - start_ts    state["peak"] = peak    state["peak_ts"] = peak_ts    state["time_to_zero"] = time_to_zero    state["lag_to_peak"] = lag_to_peak    return {        "gate": "measure_peak_and_drain",        "peak": peak,        "when": peak_ts,        "time_to_zero": time_to_zero,        "lag_to_peak": lag_to_peak,    }def run_step(base_url, step, pod_name):    url = base_url + step["path"]    method = step["method"].lower()    kwargs = {}    if "json" in step:        kwargs["json"] = step["json"]    action_entry = {        "pod": pod_name,        "method": step["method"].upper(),        "path": step["path"],    }    if "json" in step:        action_entry["json"] = step["json"]    try:        resp = getattr(requests, method)(url, **kwargs)        try:            parsed = resp.json()        except Exception:            parsed = resp.text        action_entry["result"] = {            "status": resp.status_code,            "response": parsed,        }        if step["path"] == "/pcap/stop" and resp.status_code == 200:            if isinstance(parsed, dict) and "filename" in parsed:                fname = parsed["filename"]                pcap_url = f"{base_url}/pcaps/{fname}"                local_path = os.path.join(EXPERIMENT_DIR, f"{pod_name}-{fname}")                r = requests.get(pcap_url)                if r.status_code == 200:                    with open(local_path, "wb") as f:                        f.write(r.content)                    action_entry["result"]["pcap_file"] = local_path                else:                    action_entry["result"]["pcap_file_error"] = f"Failed to download {pcap_url}"    except Exception as e:        action_entry["result"] = {            "status": "ERROR",            "response": str(e),        }    return {"action": action_entry}def main():    results = []    pod_connections = {}    state = {}    try:        for step in SEQUENCE:            if "wait" in step:                time.sleep(step["wait"])                results.append({"wait": step["wait"]})                continue            if "gate" in step:                prefix = step["pod"]                if prefix not in pod_connections:                    pod_name = get_pod_by_prefix(prefix)                    local_port = LOCAL_BASE_PORT + len(pod_connections)                    proc = port_forward(pod_name, local_port)                    time.sleep(2)                    pod_connections[prefix] = (proc, pod_name, local_port)                _, pod_name, local_port = pod_connections[prefix]                base_url = f"http://localhost:{local_port}"                fn = GATES.get(step["gate"])                if not fn:                    results.append({"gate": step["gate"], "error": "unknown gate"})                else:                    gate_result = fn(base_url, step, results, state)                    results.append(gate_result)                continue            prefix = step["pod"]            if prefix not in pod_connections:                pod_name = get_pod_by_prefix(prefix)                local_port = LOCAL_BASE_PORT + len(pod_connections)                proc = port_forward(pod_name, local_port)                time.sleep(2)                pod_connections[prefix] = (proc, pod_name, local_port)            _, pod_name, local_port = pod_connections[prefix]            base_url = f"http://localhost:{local_port}"            results.append(run_step(base_url, step, pod_name))    finally:        for proc, _, _ in pod_connections.values():            stop_process(proc)    report = {        "generated": datetime.now().isoformat(),        "namespace": NAMESPACE,        "experiment_dir": EXPERIMENT_DIR,        "state": state,        "sequence": results,    }    with open(REPORT_FILE, "w") as f:        json.dump(report, f, indent=2)    print(f"Experiment saved under {EXPERIMENT_DIR}")if __name__ == "__main__":    main()